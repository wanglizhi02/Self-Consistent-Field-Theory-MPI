#include "mpi.h"
#include "fftw3-mpi.h" 

#include "Head.h"
#include "Data.h"
#include "Mytimer.h"
#include "BasicFunc.h"
#include "FftwToolkit.h"
#include "SCFTBaseAB.h"
#include "Initialization.h"

void initialize()
{
	mytimer_t timer;

	// allocate memory 
	timer.reset();
	timer.start();
	memAllocation_no_time();
	timer.pause();
	if (myrank==0)
		printf("\t\t time cost of memory allocation : %f seconds\n", timer.get_current_time());
	timer.reset();
	timer.start();
	getIndex(indKspace, cplxDofs, DimCpt, NCpt);
	timer.pause();
	if (myrank==0)
	printf("\t\t time cost of getIndex : %f seconds\n\n", timer.get_current_time());
}

void memAllocation_no_time()
{
	singQ = (double *)malloc(sizeof(double)*Nblend);
	for(int i = 0; i < Nblend; i++) 
    {
		singQ[i] = 0.0;
	}

	// Initialize computational box
	dirBox = (double **)malloc(sizeof(double*)*DimCpt);
	rcpBox = (double **)malloc(sizeof(double*)*DimCpt);
	for(int i = 0; i < DimCpt; i++)
	{
		dirBox[i] = (double *)malloc(sizeof(double)*DimCpt);
		rcpBox[i] = (double *)malloc(sizeof(double)*DimCpt);
	}
	for(int i = 0; i < DimCpt; i++)
	{
		for(int j = 0; j < DimCpt; j++)
		{
			dirBox[i][j] = 0.0; 	rcpBox[i][j] = 0.0;
		}
	}

    gradB = (double **)malloc(sizeof(double*)*DimCpt);
    for(int i = 0; i < DimCpt; i++)
    {
        gradB[i] = (double *)malloc(sizeof(double)*DimCpt);
    }
    for(int i = 0; i < DimCpt; i++)
    {
        for(int j = 0; j < DimCpt; j++)
        {
            gradB[i][j] = 0.0;
        }
    }


	// projective matrix
	ProjMatrix = (double **)malloc(sizeof(double*)*DimPhy);
	for(int i = 0; i < DimPhy; i++)
		ProjMatrix[i] = (double *)malloc(sizeof(double)*DimCpt);

	for(int i = 0; i < DimPhy; i++)
		for(int j = 0; j < DimCpt; j++)
			ProjMatrix[i][j] = 0.0;

	for(int i = 0; i < DimPhy; i++)
			ProjMatrix[i][i] = 1.0;
	
    indKspace = (int **)malloc(sizeof(int*)*cplxDofs);
	for(int i = 0; i < cplxDofs; i++)
		indKspace[i] = (int *)malloc(sizeof(int)*DimCpt);
	for(int i = 0; i < cplxDofs; i++)
		for(int j = 0; j < DimCpt; j++)
			indKspace[i][j] = 0;
	
    indKspacelocal = (int **)malloc(sizeof(int*)*alloc_local);
	for(int i = 0; i < alloc_local; i++)
		indKspacelocal[i] = (int *)malloc(sizeof(int)*DimCpt);
	
	for(int i = 0; i < alloc_local; i++)
		for(int j = 0; j < DimCpt; j++)
			indKspacelocal[i][j] = 0;
	
	// |K|^2, |K|
	Gsquare = (double *)malloc(sizeof(double) *cplxDofs);
	Gsquarelocal = (double *)malloc(sizeof(double) *alloc_local);

	for(int i = 0; i < alloc_local; i++)
		Gsquarelocal[i]=0;

	for(int i = 0; i < cplxDofs; i++)
		Gsquare[i]=0;
	// density and field functions
    rho = (fftw_complex **)fftw_malloc(sizeof(fftw_complex*)*Nspecies);
    rhoglobal = (double **)malloc(sizeof(double*)*Nspecies);
    rhoreal = (double **)malloc(sizeof(double*)*Nspecies);

    gradW = (fftw_complex **)fftw_malloc(sizeof(fftw_complex*)*Nspecies);
    fieldW = (fftw_complex **)fftw_malloc(sizeof(fftw_complex*)*Nspecies);
	
	fieldWplus  = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*alloc_local);
	
	for(int i = 0; i < Nspecies; i++)
	{
	    fieldW[i]  = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*alloc_local);
	    gradW[i] = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*alloc_local);
        rho[i] = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*alloc_local);
        rhoglobal[i] = (double *)malloc(sizeof(double)*(2*cplxDofs));
        rhoreal[i] = (double *)malloc(sizeof(double)*(2*alloc_local));
    }
	for(int i = 0; i < Nspecies; i++)
	{
		for(int j = 0; j < alloc_local; j++)
		{
			setCplxZero(fieldW[i][j]);
			setCplxZero(gradW[i][j]);
         	setCplxZero(rho[i][j]);
        }
    }

	for(int j = 0; j < alloc_local; j++)
		setCplxZero(fieldWplus[j]);

// temp arrays for FFTW
	fftw_Ctmp = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*alloc_local);
	fftw_Rtmp = (double *)malloc(sizeof(double) *(2*alloc_local));
// fftw_plan
    PlanR2C = fftw_mpi_plan_dft_r2c(DIM, NCpt, fftw_Rtmp, fftw_Ctmp, MPI_COMM_WORLD, FFTW_ESTIMATE);
    PlanC2R = fftw_mpi_plan_dft_c2r(DIM, NCpt, fftw_Ctmp, fftw_Rtmp, MPI_COMM_WORLD, FFTW_ESTIMATE);	
}

void memAllocation()
{
	Nsplit = (int *)malloc(sizeof(int)*Nblock);
	for(int i = 0; i < Nblock; i++) Nsplit[i] = 0;
    Nsplit[0] = round((fA+1.0e-8) / dsMax);
    Nsplit[1] = round((fB+1.0e-8) / dsMax);

	Ranges = (Interval *)malloc(sizeof(Interval)*Nblock);
	Ranges[0].a = 0.0;
	Ranges[0].b = fA;

	Ranges[1].a = Ranges[0].b;
	Ranges[1].b = Ranges[0].b+fB;

	for(int i = 0; i < Nblock; i++)
		Ranges[i].n = Nsplit[i];

	Ns=0;
	for(int i = 0; i < Nblock; i++) 
		Ns += Nsplit[i];
	Ns = Ns+1;

	// forward and backward propagators
	frdQ = (fftw_complex **)fftw_malloc(sizeof(fftw_complex*)*Ns);
	bakQ = (fftw_complex **)fftw_malloc(sizeof(fftw_complex*)*Ns);
	hatq_qplus = (fftw_complex **)fftw_malloc(sizeof(fftw_complex*)*Ns);
	for(int i = 0; i < Ns; i++)
	{
		frdQ[i] = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*alloc_local);
		bakQ[i] = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*alloc_local);
		hatq_qplus[i] = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*alloc_local);
	}
	for(int i=0; i < Ns; i++)
	{
		for(int j=0; j < alloc_local; j++)
		{
			setCplxZero(frdQ[i][j]);
			setCplxZero(bakQ[i][j]);
			setCplxZero(hatq_qplus[i][j]);
		}
	}
}


void getGsquare()
{
	double *tmp = (double *)malloc(sizeof(double)*DimPhy);
	for(int i = 0; i < DimPhy; i++)
		tmp[i] = 0.0;
	for(int i = 0; i < cplxDofs; i++)
	{
		for(int k = 0; k < DimPhy; k++) tmp[k] = 0.0;
		for(int ii = 0; ii < DimCpt; ii++)
		{
			double mnt = 0.0;
			for(int jj = 0; jj < DimCpt; jj++)
			{
				mnt += indKspace[i][jj]*rcpBox[jj][ii]; 
			}
			for(int kk = 0; kk < DimPhy; kk++) 
			{
				tmp[kk] += ProjMatrix[kk][ii]*mnt;
			}
		}
		for(int kk = 0; kk < DimPhy; kk++) Gsquare[i] += pow(tmp[kk], 2);
	}

   for (int i = 0; i < local_n0; i++)
   {
	   for (int j = 0; j < NCpt[1]/2+1; j++)
	   {
          int index = i*(NCpt[1]/2+1)+j;
          int index1 = (i+local_0_start)*(NCpt[1]/2+1)+j;
          Gsquarelocal[index] = Gsquare[index1];
		}
    }         
	free(tmp);
}


void getRecipLattice(double **dBox, double **rBox)
{
	if(DimCpt==2)
	{
		double det = dBox[0][0]*dBox[1][1]-dBox[0][1]*dBox[1][0];
		rBox[0][0] =  2*PI*dBox[1][1] / det;
		rBox[1][0] = -2*PI*dBox[1][0] / det;
		rBox[0][1] = -2*PI*dBox[0][1] / det;
		rBox[1][1] =  2*PI*dBox[0][0] / det;
	}
	if(DimCpt == 3)
	{
		double aone[3], atwo[3], athree[3];
		double bone[3], btwo[3], bthree[3];
		double cone[3], ctwo[3], cthree[3];
		double volume[3];

		for(int i = 0; i < 3; i++)
		{
			aone[i]   = dBox[0][i];
			atwo[i]   = dBox[1][i];
			athree[i] = dBox[2][i];
		}

		cone[0]=atwo[1]*athree[2]-atwo[2]*athree[1];
		cone[1]=atwo[2]*athree[0]-atwo[0]*athree[2];
		cone[2]=atwo[0]*athree[1]-atwo[1]*athree[0];
		volume[0]=aone[0]*cone[0]+aone[1]*cone[1]+aone[2]*cone[2];
		bone[0]=2*PI/volume[0]*cone[0];
		bone[1]=2*PI/volume[0]*cone[1];
		bone[2]=2*PI/volume[0]*cone[2];    
	    
		ctwo[0]=athree[1]*aone[2]-athree[2]*aone[1];
		ctwo[1]=athree[2]*aone[0]-athree[0]*aone[2];
		ctwo[2]=athree[0]*aone[1]-athree[1]*aone[0];
		volume[1]=atwo[0]*ctwo[0]+atwo[1]*ctwo[1]+atwo[2]*ctwo[2];
		btwo[0]=2*PI/volume[1]*ctwo[0];
		btwo[1]=2*PI/volume[1]*ctwo[1];
		btwo[2]=2*PI/volume[1]*ctwo[2];  
	        
		cthree[0]=aone[1]*atwo[2]-aone[2]*atwo[1];
		cthree[1]=aone[2]*atwo[0]-aone[0]*atwo[2];
		cthree[2]=aone[0]*atwo[1]-aone[1]*atwo[0];
		volume[2]=athree[0]*cthree[0]+athree[1]*cthree[1]+athree[2]*cthree[2];
		bthree[0]=2*PI/volume[2]*cthree[0];
		bthree[1]=2*PI/volume[2]*cthree[1];
		bthree[2]=2*PI/volume[2]*cthree[2];   

		for(int i = 0; i < 3; i++)
		{
			rBox[0][i] = bone[i];
			rBox[1][i] = btwo[i]; 
			rBox[2][i] = bthree[i];
		}
	}
}

void writeRealData(double *field, const char *fname)
{
    int ftmp;
    FILE *fp; // = fopen(fname, "r");
    if((fp = fopen(fname, "r")) == NULL)
    {   
         printf("Cannot open file.\n");
         exit(1);
    }

    int initDofx=NCpt[0];
    int initDofy=NCpt[1];

    for(int i = 0; i < initDofx; i++)
    {   
        for(int j = 0; j < initDofy; j++)
        {
            ftmp = fscanf(fp,"%lf", &(field[i*(initDofy)+j]));
        }
    }	
    fclose(fp);
}
            
void initFieldFourier(double *fieldR, const char *fname)
{
    int ftmp;
    int initDof;
    FILE *fp; // = fopen(fname, "r");

    if((fp = fopen(fname, "r")) == NULL)
    {   
         printf("Cannot open file.\n");
         exit(1);
    }   

    fftw_complex *field = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*cplxDofs);
    ftmp = fscanf(fp, "%d", &initDof);

    int **fin = (int **)malloc(sizeof(int*)*initDof);
    for(int i = 0; i < initDof; i++)
        fin[i] = (int *)malloc(sizeof(int)*DimCpt);

    fftw_complex *fieldInput = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*initDof);
    for(int i = 0; i < initDof; i++)
    {   
        for(int j = 0; j < DimCpt; j++)
        {   
            ftmp = fscanf(fp, "%d", &(fin[i][j]));
        }   
        ftmp = fscanf(fp, "%lf", &(fieldInput[i][0]));
        ftmp = fscanf(fp, "%lf", &(fieldInput[i][1]));
    }   
    for(int i = 0; i < cplxDofs; i ++)
    {
        for(int j = 0; j < initDof; j++)
        {
            if(DimCpt == 2)
            {
                if(fin[j][0]==indKspace[i][0] && fin[j][1]==indKspace[i][1])
                {
                    field[i][0] = fieldInput[j][0];
                    field[i][1] = fieldInput[j][1];
                }
            }
            
            if(DimCpt == 3)
            {
                if(fin[j][0]==indKspace[i][0] && fin[j][1]==indKspace[i][1] && fin[j][2]==indKspace[i][2])
                {
                    field[i][0] = fieldInput[j][0];
                    field[i][1] = fieldInput[j][1];
                }
            }
        }
    }

    fclose(fp);
	int *NCpt1 = (int *)malloc(sizeof(int)*DimCpt);
	for(int i = 0; i < DimCpt; i++)
		NCpt1[i] = NCpt[i];

	fftw_plan PlanC2RP = fftw_plan_dft_c2r(DimCpt, NCpt1, fieldR, field, FFTW_MEASURE);
	fftw_execute(PlanC2RP);

    for(int i = 0; i < initDof; i++) free(fin[i]);
    free(fin);
	free(NCpt1);
    fftw_free(fieldInput);
}
