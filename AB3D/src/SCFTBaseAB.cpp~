#include "mpi.h"                                                                
#include "fftw3-mpi.h" 

#include "Head.h"
#include "time.h"
#include "Data.h"
#include "Mytimer.h"
#include "Initialization.h"
#include "BasicFunc.h"
#include "MDESolver.h"
#include "FftwToolkit.h"
#include "IntegrationToolkit.h"
#include "SCFTBaseAB.h"

#include "config.h"

void write_rho(double **RhoReal,  int iter)
{                                                                               
    char fname[255];                                                            
     sprintf(fname, "./results-%d/rho/rho.[%.4f.%.4f].[%.2f].[%d].txt", phase, fA, fB, chi, iter);
    FILE *fp=fopen(fname,"w");     
    for(int i = 0; i < realDofs; i++)
	{
				fprintf(fp,"%lf %lf \n", RhoReal[0][i], RhoReal[1][i]);
	}
    fclose(fp);                                                                 
} 

void cut(double *rholocalold, double *rholocalnew)
{
	for (int i = 0; i < local_n0; i++)
      {
         for (int j = 0; j < NCpt[1]; j++)
         {
         	for (int k = 0; k < NCpt[2]; k++)
			{
             	int index = i*NCpt[1]*(2*(NCpt[2]/2+1))+j*(2*(NCpt[2]/2+1))+k;
             	int index1 = i*NCpt[1]*NCpt[2]+j*NCpt[2]+k;
              	rholocalnew[index1] = rholocalold[index];
			}
         }
      }
}

void updatePropagator()
{
	if (myrank==0)
	{
		frdQ[0][0][0]=1.0;frdQ[0][0][1]=0.0;
	}
	int it_q =0;

	MDESolver4Adams(&Ranges[0], fieldW[0], frdQ, &it_q);// A

	MDESolver4Adams(&Ranges[1], fieldW[1], frdQ, &it_q);// A

	if (myrank==0)
	{
		bakQ[0][0][0]=1.0;	bakQ[0][0][1]=0.0;
	}

	int it_qplus =0;
	MDESolver4Adams(&Ranges[1], fieldW[1], bakQ, &it_qplus);// fB
	MDESolver4Adams(&Ranges[0], fieldW[0], bakQ, &it_qplus);// BA

}

	
double updateQ()
{
	double Q;
	if (myrank == 0)
	{
		Q = frdQ[Ns-1][0][0];
		printf("Q1 = %.20e\n", Q);   
		// printf("back = %.20e\n", bakQ[Ns-1][0][0]);         
	}
	MPI_Bcast(&Q, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD); 
	return Q;
}

void updateOrderParameter()
{
	for(int i = 0; i < Ns; i++)
	{
		int it_inv1 = Ns-1-i;
		hatConv(hatq_qplus[i], frdQ[i], bakQ[it_inv1]);
		
	}
	int index = 0;
	for(int i = 0; i < Nspecies; i++)
	{
		integration(rho[i], &Ranges[i], hatq_qplus, &index, singQ[0]);
		
	}
}

void get_gradB(double dh)
{    
     double **oldB; 
     oldB = (double **)malloc(sizeof(double*)*DimCpt);
     for(int i = 0; i < DimCpt; i++)
     {   
         oldB[i] = (double *)malloc(sizeof(double)*DimCpt);
     }
     for(int i = 0; i < DimCpt; i++)
     {
         for(int j = 0; j < DimCpt; j++)
         {   
             oldB[i][j] = 0.0;
         }
     }

    MatCopy(oldB, rcpBox, DimCpt, DimCpt);

    for(int i = 0; i < DimCpt; i++)
    {   
	rcpBox[i][i] += dh;
    }
    double FR = calPartialF();
    MatCopy(rcpBox, oldB, DimCpt, DimCpt);
    
    for(int i = 0; i < DimCpt; i++)
    {   
	rcpBox[i][i] -= dh;

    }
    double FL = calPartialF();
    MatCopy(rcpBox, oldB, DimCpt, DimCpt);
    
    if(myrank==0)
    printf("[FR, FL] = [%.15e, \t %.15e]\n", FR, FL);
    
    for(int i = 0; i < DimCpt; i++)
	gradB[i][i] = (FR-FL)/(2.0*dh);
    
    
     for(int i = 0; i < DimCpt; i++)
	     free(oldB[i]);
    free(oldB);

}


void SimpleMixing(double *resGradW, double *resGradB)
{
	 double dt1 = 0.1;
	 double dt2 = 0.1;
	 double dt3 = 1.0e-06;
	 //update w
	 FuncsLinear3Cplx(gradW[0], alloc_local, chi*Ndeg, rho[1], 1.0, fieldWplus, -1.0, fieldW[0]);
	 FuncsLinear3Cplx(gradW[1], alloc_local, chi*Ndeg, rho[0], 1.0, fieldWplus, -1.0, fieldW[1]);
	 FuncAddToCplx(fieldW[0], alloc_local, dt1, gradW[0]);
	 FuncAddToCplx(fieldW[1], alloc_local, dt2, gradW[1]);
	 //update w_plus
	 FuncsLinear2Cplx(fieldWplus, alloc_local, 0.5, fieldW[0], 0.5, fieldW[1]);
	 if (myrank ==0)
	 {
		fieldWplus[0][0] -= 0.5*chi*Ndeg;
	 }
 
	 double res1 = normCplxInfty(gradW[0], alloc_local);
	double res2 = normCplxInfty(gradW[1], alloc_local);
	 if (myrank ==0)
	{
	   printf("[res1, res2] = [%.20e, \t %.20e]\n", res1, res2);
	}
	MPI_Reduce(&res1, &resGradW[0], 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);      
	MPI_Reduce(&res2, &resGradW[1], 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);     
	//update domain
	double dh = 1e-05;
	get_gradB(dh);
	
	MatsAdd(rcpBox, 1.0, gradB, dt3, DimCpt, DimCpt);

	if(myrank==0)
	{
		printf("\n\t\t\t === Direct Box === \n");
		getRecipLattice(rcpBox, dirBox);
		MatPrint(dirBox, DimCpt, DimCpt);
		printf("\n");
	}
	  
	double resB1 = normRealInfty(gradB[0], DimCpt);
	double resB2 = normRealInfty(gradB[1], DimCpt);
	double resB3 = normRealInfty(gradB[2], DimCpt);
	 if (myrank ==0)
	printf("[resB1, resB2, resB3] = [%.20e, \t %.20e, \t %.20e]\n", resB1, resB2, resB3);

	MPI_Reduce(&resB1, &resGradB[0], 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);      
	MPI_Reduce(&resB2, &resGradB[1], 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);  
	MPI_Reduce(&resB3, &resGradB[2], 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);  
}

double updateHamilton()
{
	double tmpAB;
	tmpAB = Intergral_space(rho[0], rho[1]);


	double tmpA, tmpB, tmpWplus;
	tmpA = Intergral_space(fieldW[0], rho[0]);
	tmpB = Intergral_space(fieldW[1], rho[1]);


	fftw_complex *rhotmp = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*alloc_local);	
	FuncsLinear2Cplx(rhotmp, alloc_local, 1.0, rho[0], 1.0, rho[1]);
	tmpWplus = Intergral_space(fieldWplus, rhotmp);

	if(myrank==0)
	{
		internalEnergy = chi*Ndeg*tmpAB - tmpA -tmpB;
	//	internalEnergy = chi*Ndeg*tmpAB - tmpA -tmpB + tmpWplus - fieldWplus[0][0];
	printf("entropicEnergy1 = %.15e\n", entropicEnergy1);                

	    entropicEnergy1= - std::log(singQ[0]);

		Hamilton = internalEnergy + entropicEnergy1;
	printf("H = %.15e\t %15e\t \n", internalEnergy, chi*Ndeg*tmpAB);                
	}
	 
	MPI_Bcast(&Hamilton, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
	fftw_free(rhotmp);
    return Hamilton;
}
double evlSaddle(double tol)
{
	mytimer_t timer;
	int iterator = 0;
	double error;
	double Energy, oldEnergy, diffEnergy;
	oldEnergy = 100.0;
	Energy = 100.0;
	double *resGradW  = (double *)malloc(sizeof(double)*Nspecies);
	double *resGradB = (double *)malloc(sizeof(double)*DimCpt);
	for(int i = 0; i < Nspecies; i++) 
	{
		resGradW[i] = 0.0;
	}
	for(int i = 0; i < DimCpt; i++) 
		resGradB[i] = 0.0;
	
	double resinftyW = 1.0;
	double resinftyB = 1.0;
	double **RhoReal,  **rhorealnew;
    RhoReal = (double **)malloc(sizeof(double*) *Nspecies);
    rhorealnew = (double **)malloc(sizeof(double*) *Nspecies);
     for(int i = 0; i < Nspecies; i++)
    {
        RhoReal[i] = (double *)malloc(sizeof(double)*2*cplxDofs);
        rhorealnew[i] = (double *)malloc(sizeof(double)*(local_n0*NCpt[1]*NCpt[2]));
    }
   
	do{
		getGsquare();

		iterator++; 
		timer.reset();
		timer.start();
		// printf("2order\n");
		updatePropagator();
		timer.pause();

		if (myrank==0)
		printf("\t\t time cost of updatePropagator : %f seconds\n", timer.get_current_time());
		
		MPI_Barrier(MPI_COMM_WORLD);


		timer.reset();
		timer.start();
		singQ[0]=updateQ();
		MPI_Barrier(MPI_COMM_WORLD);
		timer.pause();
		if (myrank==0)
        printf("\t\t time cost of updateQ          : %f seconds\n", timer.get_current_time());
		
		timer.reset();
		timer.start();
		updateOrderParameter();

		MPI_Barrier(MPI_COMM_WORLD);
		timer.pause();
		if (myrank==0)
        printf("\t\t time cost of updateOrderParameter    : %f seconds\n", timer.get_current_time());

     
		timer.reset();
		timer.start();
		updateField(resGradW,resGradB);

		MPI_Barrier(MPI_COMM_WORLD);
		timer.pause();
		if (myrank==0)
        printf("\t\t time cost of updateField      : %f seconds\n", timer.get_current_time());

		

		timer.reset();
		timer.start();
		Energy = updateHamilton();

		MPI_Barrier(MPI_COMM_WORLD);
		timer.pause();
		if (myrank==0)
        printf("\t\t time cost of updateHamilton   : %f seconds\n", timer.get_current_time());

		if (myrank==0)
		{
			resinftyW = normRealInfty(resGradW, Nspecies);
			resinftyB  = normRealInfty(resGradB, DimCpt);
			printf("resinftyW=%.20f resinftyB=%.20f\n",resinftyW,resinftyB);

		}
		// save data
		for(int i=0;i< Nspecies; i++)
			FftwC2R(rhoreal[i], rho[i]);

		for(int i=0;i< Nspecies; i++)
			cut(rhoreal[i], rhorealnew[i]);
 
		n = (int *)malloc(sizeof(int)*nprocs);

		a = local_n0*NCpt[1]*NCpt[2];
		MPI_Allgather(&a, 1, MPI_INT, n, 1, MPI_INT, MPI_COMM_WORLD);

		displs= (int *)malloc(sizeof(int)*nprocs);//每个进程的偏移量
		displs[0] = 0;
		for(int i=1;i< nprocs; i++)
		{
			displs[i] = displs[i-1]+ n[i-1];
		}

		for(int i=0;i< Nspecies; i++)
			MPI_Gatherv(rhorealnew[i], a, MPI_DOUBLE, RhoReal[i], n, displs, MPI_DOUBLE, 0, MPI_COMM_WORLD);
		diffEnergy = fabs(Energy-oldEnergy);
		 if (myrank ==0)
		printf("diffEnergy %f\n",diffEnergy);

		if(iterator==1 ||iterator%500== 0)
		{
			if (myrank == 0)
				write_rho(RhoReal, iterator);//	
		}
		if (myrank == 0)
		{
			   char fname[255];
			   sprintf(fname, "./results-%d/rst1.[%.4f.%.4f]-[%.2f].dat", phase, fA, fB, chi);
			   FILE *fp=fopen(fname,"a");
	           fprintf(fp, "%.4f\t %.4f\t  %.6e\t  %.6e\t  %.6e\t   %.7e\t  %.7e\t  %.7e\t  %.7e\t\n", dirBox[0][0], dirBox[1][1], diffEnergy, resinftyW, resinftyB, singQ[0], Energy, internalEnergy, entropicEnergy1);
			   fclose(fp);
		}
	  	if (myrank==0)
        {
			printf("ITERATOR %d:  singQ = %.20e\t, Energy=%.20e\t,  diffhm =%.20e, resinftyW = %.20e,  resinftyB=%.20e\n", iterator, singQ[0],  Energy, diffEnergy, resinftyW,  resinftyB);	
            printf( "%.5f\t %.5f\t %.20e\t %.20e\n", dirBox[0][0], dirBox[1][1], internalEnergy, entropicEnergy1);
        }	
        oldEnergy = Energy;
		
	    // if (iterator > ItMax)
	    if (iterator > 0)
				break;
           
		if(diffEnergy > 10000)
			break;
	}while(diffEnergy> tol);

	if (myrank == 0)
	{
       		write_rho(RhoReal,  iterator);
	}
	if (myrank ==0)
	{
		char fname2[255];                                                           
		sprintf(fname2, "./results-%d/Data/Data.[%.4f.%.4f]-[%.2f].dat", phase, fA, fB, chi);
    	FILE *fp2=fopen(fname2,"w");     
		fprintf(fp2," %ld\t %ld\t  %.5f\t %d\t  %d\n", NCpt[0], NCpt[1], dsMax, phase, iterator);
		fprintf(fp2,"%.4f\t %.4f\t  \n", fA, fB);
	    fprintf(fp2,"%.2f\t \n", chi);
		fprintf(fp2,"%.4f\t %.4f\n", dirBox[0][0], dirBox[1][1]);
	    fprintf(fp2, "%.15e\t %.15e\n",diffEnergy, singQ[0]);
	    fprintf(fp2, "%.15e\t %.15e\t\n",resinftyW,  resinftyB);
        fprintf(fp2, "%.15e\t %.15e\t %.15e\n",Energy, internalEnergy, entropicEnergy1);
        fclose(fp2);  
	}

	free(resGradW);
	free(resGradB);
	for(int i = 0; i < Nspecies; i++)
	{
		free(RhoReal[i]);
		free(rhorealnew[i]);
	}
	free(RhoReal);
	free(rhorealnew);
   	return Energy;
}


void updateField(double *resGradW, double *resGradB)
{
	SimpleMixing(resGradW, resGradB);
}

double calPartialF()
{
	double partialF = 0;
	getGsquare();
	updatePropagator();
	double Q = updateQ();
	partialF -= std::log(Q);
	return partialF;
}
void SCFTiteration(double tol)
{
	evlSaddle(tol);

}
